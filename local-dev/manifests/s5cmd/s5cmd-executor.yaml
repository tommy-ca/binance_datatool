---
# s5cmd Executor ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: s5cmd-executor-config
  namespace: s5cmd
data:
  config.yaml: |
    # s5cmd Executor Configuration
    # High-performance S3 operations for Crypto Lakehouse
    
    s5cmd:
      version: "v2.2.2"
      log_level: "info"
      retry_count: 3
      concurrency: 10
      part_size: "16MB"
      multipart_threshold: "64MB"
      multipart_chunksize: "16MB"
      endpoint_url: "http://minio-service.minio:9000"
      use_list_objects_v1: false
      dry_run: false
      stats: true
      progress: true
      
    executor:
      max_workers: 5
      queue_size: 100
      timeout_seconds: 300
      metrics_port: 8080
      health_port: 8081
      
    aws:
      access_key_id: "s5cmd"
      secret_access_key: "s5cmd123456"
      region: "us-east-1"
      
    storage:
      default_bucket: "crypto-lakehouse-data"
      temp_bucket: "crypto-lakehouse-logs"
      backup_bucket: "crypto-lakehouse-backups"
      
    performance:
      enable_multipart: true
      enable_checksum: true
      enable_compression: false
      buffer_size: "1MB"
      
    telemetry:
      enable_metrics: true
      enable_tracing: true
      otel_endpoint: "http://otel-collector.observability:4318"
      service_name: "s5cmd-executor"
      service_version: "1.0.0"
      
  entrypoint.sh: |
    #!/bin/bash
    set -euo pipefail
    
    # s5cmd Executor Entrypoint Script
    echo "Starting s5cmd Executor..."
    
    # Configure AWS credentials
    export AWS_ACCESS_KEY_ID="s5cmd"
    export AWS_SECRET_ACCESS_KEY="s5cmd123456"
    export AWS_REGION="us-east-1"
    export AWS_ENDPOINT_URL="http://minio-service.minio:9000"
    
    # Configure OpenTelemetry
    export OTEL_EXPORTER_OTLP_ENDPOINT="http://otel-collector.observability:4318"
    export OTEL_EXPORTER_OTLP_PROTOCOL="http/protobuf"
    export OTEL_SERVICE_NAME="s5cmd-executor"
    export OTEL_RESOURCE_ATTRIBUTES="service.name=s5cmd-executor,service.version=1.0.0,environment=local"
    
    # Test connectivity to MinIO
    echo "Testing MinIO connectivity..."
    until s5cmd --endpoint-url="$AWS_ENDPOINT_URL" ls s3://crypto-lakehouse-data/ > /dev/null 2>&1; do
      echo "Waiting for MinIO to be ready..."
      sleep 5
    done
    echo "MinIO is ready!"
    
    # Start the executor
    echo "Starting s5cmd executor service..."
    exec python3 /app/executor.py
    
  executor.py: |
    #!/usr/bin/env python3
    """
    s5cmd Executor Service
    High-performance S3 operations executor for Crypto Lakehouse
    """
    
    import asyncio
    import json
    import logging
    import os
    import subprocess
    import time
    from datetime import datetime
    from pathlib import Path
    from typing import Dict, List, Optional
    
    import aiohttp
    from aiohttp import web
    from prometheus_client import Counter, Histogram, Gauge, start_http_server
    from opentelemetry import trace
    from opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter
    from opentelemetry.sdk.trace import TracerProvider
    from opentelemetry.sdk.trace.export import BatchSpanProcessor
    from opentelemetry.instrumentation.aiohttp_client import AioHttpClientInstrumentor
    
    # Prometheus metrics
    OPERATIONS_TOTAL = Counter('s5cmd_operations_total', 'Total s5cmd operations', ['operation', 'status'])
    OPERATION_DURATION = Histogram('s5cmd_operation_duration_seconds', 'Duration of s5cmd operations', ['operation'])
    BYTES_TRANSFERRED = Counter('s5cmd_bytes_transferred_total', 'Total bytes transferred by s5cmd')
    ACTIVE_OPERATIONS = Gauge('s5cmd_active_operations', 'Currently active s5cmd operations')
    QUEUE_SIZE = Gauge('s5cmd_queue_size', 'Current queue size')
    
    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    logger = logging.getLogger('s5cmd-executor')
    
    class S5cmdExecutor:
        def __init__(self, config_path: str = '/etc/s5cmd/config.yaml'):
            self.config = self._load_config(config_path)
            self.queue = asyncio.Queue(maxsize=self.config['executor']['queue_size'])
            self.active_operations = 0
            self.setup_telemetry()
            
        def _load_config(self, config_path: str) -> Dict:
            """Load configuration from YAML file"""
            import yaml
            with open(config_path, 'r') as f:
                return yaml.safe_load(f)
                
        def setup_telemetry(self):
            """Setup OpenTelemetry tracing"""
            trace.set_tracer_provider(TracerProvider())
            tracer_provider = trace.get_tracer_provider()
            
            otlp_exporter = OTLPSpanExporter(
                endpoint=self.config['telemetry']['otel_endpoint']
            )
            span_processor = BatchSpanProcessor(otlp_exporter)
            tracer_provider.add_span_processor(span_processor)
            
            self.tracer = trace.get_tracer(__name__)
            AioHttpClientInstrumentor().instrument()
            
        async def execute_s5cmd(self, operation: str, args: List[str]) -> Dict:
            """Execute s5cmd command with telemetry"""
            operation_start = time.time()
            
            with self.tracer.start_as_current_span(f"s5cmd_{operation}") as span:
                try:
                    ACTIVE_OPERATIONS.inc()
                    self.active_operations += 1
                    
                    # Build s5cmd command
                    cmd = [
                        's5cmd',
                        '--endpoint-url', self.config['s5cmd']['endpoint_url'],
                        '--log-level', self.config['s5cmd']['log_level'],
                        '--retry-count', str(self.config['s5cmd']['retry_count']),
                        '--numworkers', str(self.config['s5cmd']['concurrency']),
                        operation
                    ] + args
                    
                    # Add span attributes
                    span.set_attribute("s5cmd.operation", operation)
                    span.set_attribute("s5cmd.args", ' '.join(args))
                    
                    logger.info(f"Executing: {' '.join(cmd)}")
                    
                    # Execute command
                    process = await asyncio.create_subprocess_exec(
                        *cmd,
                        stdout=asyncio.subprocess.PIPE,
                        stderr=asyncio.subprocess.PIPE
                    )
                    
                    stdout, stderr = await process.communicate()
                    
                    duration = time.time() - operation_start
                    
                    if process.returncode == 0:
                        OPERATIONS_TOTAL.labels(operation=operation, status='success').inc()
                        span.set_attribute("s5cmd.status", "success")
                        logger.info(f"Operation {operation} completed successfully in {duration:.2f}s")
                        
                        return {
                            'status': 'success',
                            'operation': operation,
                            'duration': duration,
                            'stdout': stdout.decode(),
                            'stderr': stderr.decode(),
                            'timestamp': datetime.utcnow().isoformat()
                        }
                    else:
                        OPERATIONS_TOTAL.labels(operation=operation, status='error').inc()
                        span.set_attribute("s5cmd.status", "error")
                        span.set_attribute("s5cmd.error", stderr.decode())
                        logger.error(f"Operation {operation} failed: {stderr.decode()}")
                        
                        return {
                            'status': 'error',
                            'operation': operation,
                            'duration': duration,
                            'error': stderr.decode(),
                            'timestamp': datetime.utcnow().isoformat()
                        }
                        
                except Exception as e:
                    OPERATIONS_TOTAL.labels(operation=operation, status='error').inc()
                    span.record_exception(e)
                    logger.error(f"Exception during {operation}: {str(e)}")
                    
                    return {
                        'status': 'error',
                        'operation': operation,
                        'error': str(e),
                        'timestamp': datetime.utcnow().isoformat()
                    }
                finally:
                    ACTIVE_OPERATIONS.dec()
                    self.active_operations -= 1
                    OPERATION_DURATION.labels(operation=operation).observe(time.time() - operation_start)
                    
        async def health_check(self, request):
            """Health check endpoint"""
            try:
                # Test basic s5cmd connectivity
                result = await self.execute_s5cmd('ls', ['s3://crypto-lakehouse-data/'])
                if result['status'] == 'success':
                    return web.json_response({
                        'status': 'healthy',
                        'active_operations': self.active_operations,
                        'queue_size': self.queue.qsize(),
                        'timestamp': datetime.utcnow().isoformat()
                    })
                else:
                    return web.json_response({
                        'status': 'unhealthy',
                        'error': result.get('error', 'Unknown error')
                    }, status=503)
            except Exception as e:
                return web.json_response({
                    'status': 'unhealthy',
                    'error': str(e)
                }, status=503)
                
        async def execute_operation(self, request):
            """Execute s5cmd operation endpoint"""
            try:
                data = await request.json()
                operation = data.get('operation')
                args = data.get('args', [])
                
                if not operation:
                    return web.json_response({
                        'status': 'error',
                        'error': 'Operation is required'
                    }, status=400)
                    
                # Add to queue
                await self.queue.put((operation, args))
                QUEUE_SIZE.set(self.queue.qsize())
                
                # Execute operation
                result = await self.execute_s5cmd(operation, args)
                
                return web.json_response(result)
                
            except Exception as e:
                logger.error(f"Error executing operation: {str(e)}")
                return web.json_response({
                    'status': 'error',
                    'error': str(e)
                }, status=500)
                
        async def get_stats(self, request):
            """Get executor statistics"""
            return web.json_response({
                'active_operations': self.active_operations,
                'queue_size': self.queue.qsize(),
                'config': self.config,
                'timestamp': datetime.utcnow().isoformat()
            })
            
        def create_app(self):
            """Create aiohttp application"""
            app = web.Application()
            app.router.add_get('/health', self.health_check)
            app.router.add_post('/execute', self.execute_operation)
            app.router.add_get('/stats', self.get_stats)
            return app
            
    async def main():
        """Main entry point"""
        executor = S5cmdExecutor()
        
        # Start Prometheus metrics server
        start_http_server(8080)
        logger.info("Prometheus metrics server started on port 8080")
        
        # Create and start web application
        app = executor.create_app()
        runner = web.AppRunner(app)
        await runner.setup()
        
        site = web.TCPSite(runner, '0.0.0.0', 8081)
        await site.start()
        
        logger.info("s5cmd Executor started on port 8081")
        logger.info("Health check: http://localhost:8081/health")
        logger.info("Metrics: http://localhost:8080/metrics")
        
        # Keep running
        try:
            await asyncio.Future()  # Run forever
        except KeyboardInterrupt:
            logger.info("Shutting down...")
        finally:
            await runner.cleanup()
            
    if __name__ == '__main__':
        asyncio.run(main())

---
# s5cmd Executor Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: s5cmd-executor
  namespace: s5cmd
  labels:
    app: s5cmd-executor
    component: data-transfer
spec:
  replicas: 2
  selector:
    matchLabels:
      app: s5cmd-executor
  template:
    metadata:
      labels:
        app: s5cmd-executor
        component: data-transfer
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      containers:
      - name: s5cmd-executor
        image: s5cmd-executor:local
        imagePullPolicy: Never
        ports:
        - containerPort: 8080
          name: metrics
        - containerPort: 8081
          name: api
        env:
        - name: AWS_ACCESS_KEY_ID
          valueFrom:
            secretKeyRef:
              name: minio-credentials
              key: access_key
        - name: AWS_SECRET_ACCESS_KEY
          valueFrom:
            secretKeyRef:
              name: minio-credentials  
              key: secret_key
        - name: AWS_ENDPOINT_URL
          valueFrom:
            secretKeyRef:
              name: minio-credentials
              key: endpoint
        - name: AWS_REGION
          value: "us-east-1"
        - name: OTEL_EXPORTER_OTLP_ENDPOINT
          value: "http://otel-collector.observability:4318"
        - name: OTEL_EXPORTER_OTLP_PROTOCOL
          value: "http/protobuf"
        - name: OTEL_SERVICE_NAME
          value: "s5cmd-executor"
        - name: OTEL_RESOURCE_ATTRIBUTES
          value: "service.name=s5cmd-executor,service.version=1.0.0,environment=local"
        resources:
          requests:
            cpu: 200m
            memory: 256Mi
          limits:
            cpu: 1000m
            memory: 512Mi
        volumeMounts:
        - name: config
          mountPath: /etc/s5cmd
        - name: app-volume
          mountPath: /app
        livenessProbe:
          httpGet:
            path: /health
            port: 8081
          initialDelaySeconds: 30
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /health
            port: 8081
          initialDelaySeconds: 10
          periodSeconds: 10
      volumes:
      - name: config
        configMap:
          name: s5cmd-executor-config
          defaultMode: 0755
      - name: app-volume
        configMap:
          name: s5cmd-executor-config
          defaultMode: 0755

---
apiVersion: v1
kind: Service
metadata:
  name: s5cmd-executor
  namespace: s5cmd
  labels:
    app: s5cmd-executor
    component: data-transfer
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "8080"
    prometheus.io/path: "/metrics"
spec:
  selector:
    app: s5cmd-executor
  ports:
  - name: metrics
    port: 8080
    targetPort: 8080
    protocol: TCP
  - name: api
    port: 8081
    targetPort: 8081
    protocol: TCP
  type: ClusterIP

---
# Secret for MinIO credentials (referenced from minio namespace)
apiVersion: v1
kind: Secret
metadata:
  name: minio-credentials
  namespace: s5cmd
type: Opaque
data:
  # s5cmd:s5cmd123456 base64 encoded
  access_key: czVjbWQ=
  secret_key: czVjbWQxMjM0NTY=
  endpoint: aHR0cDovL21pbmlvLXNlcnZpY2UubWluaW86OTAwMA==

---
# Docker build job for s5cmd executor image
apiVersion: batch/v1
kind: Job
metadata:
  name: build-s5cmd-executor
  namespace: s5cmd
  labels:
    app: build-s5cmd-executor
    component: initialization
spec:
  template:
    metadata:
      labels:
        app: build-s5cmd-executor
        component: initialization
    spec:
      restartPolicy: OnFailure
      containers:
      - name: docker-build
        image: docker:24-dind
        securityContext:
          privileged: true
        env:
        - name: DOCKER_TLS_CERTDIR
          value: ""
        command:
        - sh
        - -c
        args:
        - |
          # Start Docker daemon
          dockerd &
          sleep 10
          
          # Create Dockerfile
          cat > /tmp/Dockerfile << 'EOF'
          FROM python:3.11-slim
          
          # Install s5cmd
          RUN apt-get update && apt-get install -y \
              curl \
              ca-certificates \
              && curl -L https://github.com/peak/s5cmd/releases/download/v2.2.2/s5cmd_2.2.2_Linux-64bit.tar.gz \
              | tar -xz -C /usr/local/bin/ \
              && chmod +x /usr/local/bin/s5cmd \
              && apt-get clean \
              && rm -rf /var/lib/apt/lists/*
          
          # Install Python dependencies
          RUN pip install --no-cache-dir \
              aiohttp \
              prometheus-client \
              opentelemetry-api \
              opentelemetry-sdk \
              opentelemetry-exporter-otlp \
              opentelemetry-instrumentation-aiohttp-client \
              pyyaml
          
          # Create app directory
          WORKDIR /app
          
          # Copy configuration and scripts
          COPY --from=configmap config.yaml /etc/s5cmd/config.yaml
          COPY --from=configmap executor.py /app/executor.py
          COPY --from=configmap entrypoint.sh /app/entrypoint.sh
          
          RUN chmod +x /app/entrypoint.sh /app/executor.py
          
          EXPOSE 8080 8081
          
          ENTRYPOINT ["/app/entrypoint.sh"]
          EOF
          
          # Build image
          docker build -t s5cmd-executor:local -f /tmp/Dockerfile .
          
          echo "s5cmd-executor image built successfully!"
        volumeMounts:
        - name: docker-socket
          mountPath: /var/run/docker.sock
        - name: config
          mountPath: /configmap
      volumes:
      - name: docker-socket
        hostPath:
          path: /var/run/docker.sock
      - name: config
        configMap:
          name: s5cmd-executor-config